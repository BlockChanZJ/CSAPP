# phase_1 

Public speaking is very easy.

# phase_2

太菜了做了一个礼拜qwq
关键是搞清楚
+------------+-------------+---------------------------+---------------+
|    Type    |  Form       |   Operand Value           |   Name        |
+------------+-------------+---------------------------+---------------+
| Memory     |Imm(Eb,Ei,s) |M[Imm + R[Eb]+ R[Ei] * s]  |Scaled indexed |
+------------+-------------+---------------------------+---------------+
$esi 存储的是输入的第一个数的地址
也就是-0x18(%ebp),可以确定的是第一个数字为1

然后搞清楚这句话
   0x08048b79 <+49>:	imul   -0x4(%esi,%ebx,4),%eax
   0x08048b7e <+54>:	cmp    %eax,(%esi,%ebx,4)
$ebx 每次+1, $eax = $ebx + 1
所以实际上这句话就是把你输出的前一个数字×$eax倍，和后一个比较
于是就是
1 * 2 = 2 * 3 = 6 * 4 = 24 * 5 = 120 * 6 = 720
答案就是1 2 6 24 120 720

# phase_3
首先 x/s 0x80497de 可以判断输入的是"%d %c %d"
输入的地址分别为-0xc(%ebp) -0x5(%ebp) -0x4(%ebp)
且根据
   0x08048bc9 <+49>:	cmpl   $0x7,-0xc(%ebp)
   0x08048bcd <+53>:	ja     0x8048c88 <phase_3+240>
然后bomb!!
判断出 输入的第一个数字需要 <= 7

根据
   0x08048bd3 <+59>:	mov    -0xc(%ebp),%eax
   0x08048bd6 <+62>:	jmp    *0x80497e8(,%eax,4)
然后x/x *0x80497e8 判断出这是一个switch case跳转，且应该有7个选项
于是我尝试了*(-0xc(%ebp)) = 0的情况
发现第三个数据需要为777，第二个字母需要为113，查询ascii表是q
所以答案为0 q 777

# phase_4
根据
   0x08048cec <+12>:	lea    -0x4(%ebp),%eax

   0x08048d03 <+35>:	cmpl   $0x0,-0x4(%ebp)
   0x08048d07 <+39>:	jg     0x8048d0e <phase_4+46>
可以判断输入的数字放在-0x4(%ebp)中，然后需要大于0

根据这一段
   0x08048d14 <+52>:	push   %eax
   0x08048d15 <+53>:	call   0x8048ca0 <func4>
   0x08048d1a <+58>:	add    $0x10,%esp
   0x08048d1d <+61>:	cmp    $0x37,%eax
   0x08048d20 <+64>:	je     0x8048d27 <phase_4+71>
   0x08048d22 <+66>:	call   0x80494fc <explode_bomb>
   0x08048d27 <+71>:	mov    %ebp,%esp
可以判断func4的返回结果为0x37 = 55, 且$eax中存放的是输入的数字(非地址)
然后看func4这个函数
发现他是一个明显的fibonacci数列，数列的第(输入数)项是55。
于是尝试了10 11 9，发现答案是9

# phase_5

